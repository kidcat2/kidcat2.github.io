---
title: "컴퓨터 네트워크 #4"
date: 2023-7-11 +0000
categories: [Major, Computer Network]
tags: [컴퓨터 네트워크, Computer Network]
math: true
published : true
---

---
### 목차

1. 패킷교환의 원리
2. 패킷교환의 2가지 방법
3. 패킷크기 전송시간
4. 회선교환과 패킷교환의 비교

> 패킷교환의 배경
    회선교환은 전용회선을 통하기 때문에, 이용률이 높은 음성통신 같은 경우에 강점을 보였다. 회선교환 기술이 사용될 당시에는 데이터 통신에 가장 중점을 둔 것이 음성통신 이었으므로 상관이 없었지만, 시대가 흐르면서 다양한 데이터 ( 메일, 영상 ) 의 등장으로 회선교환의 단점이 나타났고 패킷교환 기술이 등장하였다.
{: .prompt-info }

패킷교환은

- PC가 서버에 로그온 되기만 하면, 사용자가 아무것도 하지 않아도 하나의 회선을 계속 할당 받기 때문에 비효율적이다.
- 일정한 데이터 전송율을 가지므로, 연결된 두 스테이션은 항상 송신률과 수신률이 같아야 한다. 이는 네트워크 활용을 제한한다.

---

### **패킷교환의 원리**

`패킷`이란, 전송할 데이터를 여러 개로 쪼갠 것 중 하나를 말한다.

쉽게 말해서 전송할 데이터 `100 → 패킷(23)` 으로 만들 경우 **(데이터(20)+헤더(3)) * 5** 으로 쪼개서 전송한다.

이 때 `헤더`(제어정보) 는 경로 배정하여, 목적지로 전달하기 위한 정보를 가지고 있다.

이러한 패킷이 `스테이션`→`노드`, `노드`→`노드` 로 전송되며, 패킷을 받은 노드는 `큐(QUEUE)` 에 패킷을 잠시 저장해둔다. 이후 다음 노드를 결정하면, 순서에 따라 패킷을 전송한다.

패킷교환은 노드 사이의 링크를 동적으로 선택하므로 효율이 높아진다.

또한 데이터 전송률의 변환이 가능해서 두 스테이션 간에 각자 적절한 전송률로 노드에 연결되어 상호 교환할 수 있다. 

데이터를 큐에 저장해 두기 때문에, 차단 현상이 일어나지 않는다. 

통신량이 많아져도 큐에 계속 가지고 있으면 되기 때문이다. 큐에는 우선순위가 있기 때문에, 패킷 전송의 순서도 자유롭게 결정할 수 있다.


### **패킷교환의 2가지 방법**

1. **데이터그램**

    `데이터그램`은 모든 패킷을 개별적으로 취급하고 전송한다. 

    각자의 패킷은 매번 노드들이 현재 네트워크 상황에 맞게 가장 최적의 다음 노드를 선택해 전송한다. 

    따라서 패킷이 순서대로 목적지에 도착하지 않는다. 3번 패킷이 전송될 때 네트워크가 원활했다면, 1번 패킷보다 먼저 도착할 수 있다.

    따라서 목적지나 출구 라우터에서는 이 패킷들을 순서대로 조립하고, 네트워크 내에서 패킷이 분실 되었는지 확인, 복구하는 책임을 가진다.

2. **가상회선**

    `가상회선`은 회선교환처럼 미리 갈 노드들을 정하고, 회선을 선택해서 그 회선으로만 데이터를 전송한다.

    따라서 패킷들은 순서대로 도착한다. 또한 회선교환이랑 다르게 설정된 가상회선을 다른 스테이션에서도 이용할 수 있다.

3. **데이터그램 vs 가상회선**

    가상회선은 순서대로 패킷을 보내기 때문에, `순서화`(sequencing) 과 `오류제어같은` 서비스를 제공할 수 있고, 분실된 패킷을 보다 빨리 발견해 재전송 요청을 할 수 있다. 

    또한 노드에서 경로를 결정하는 것이 아니기 때문에 보다 빨리 네트워크를 통과한다.

    데이터그램의 경우 미리 회선을 설정하지 않기 때문에 (1) `호 설정 단계` (발신지 → 수신지로 회선을 정할 때 `call` 하는 단계)가 없고, (2) 혼잡한 네트워크를 피해간다. 

    또한 노드가 고장나도 이전 노드가 경로를 알아서 우회해 선택하기 때문에 패킷이 분실될 가능성이 적다. 따라서 (3) 신뢰성이 높다.


### 패킷크기와 전송시간

1. **패킷 크기에 따른 전송시간**

    각 노드들은 전이중 방식으로 패킷을 전송하기 때문에, 노드가 데이터를 수신 받으면서 동시에 다음 노드로 전송할 수 있다. 

    이러한 특징이 패킷크기가 전송시간을 결정하게 한다.

    ex. 40옥텟 (`옥텟` = 8bit) 짜리 데이터가 `스테이션` → `노드1` → `노드2` → `스테이션`으로 전달된다고 하자.

    <br>

    - **43옥텟의 패킷 (데이터 40 / 헤더 3)**

        총 전송은 3번이므로 $$43 \times 3 = 129$$ 옥텟타임이 걸린다.

    - **23옥텟의 패킷 x 2 ( 데이터20 / 헤더3 )**

        **1번 패킷**이 **노드1**로 전송되고, **노드1**에서는 2번 패킷을 수신받으면서 동시에 1번패킷을 **노드2**로 전송한다.

        따라서 $$23 \times 4 = 92$$ 옥텟타임이 걸린다.

        이 때 패킷 수에 따라 걸리는 시간은

        **= (마지막 패킷 전 패킷이 1번 노드로 도착할 때 까지의 시간) + (마지막 패킷이 수신지에 전달되는 시간)** 이다.

        예를 들어 패킷이 8개고, 패킷이 다음 노드까지 도착하는데 T초가 걸린다면

        마지막 패킷 전 패킷(7번 패킷) 이 **노드1**에 도착하는데 걸리는 시간 = 7T (1번 T, 2번 T, ... 7번T)

        마지막 패킷 ( 8번 패킷 ) 이 목적지에 도착하는데 걸리는 시간 = T'

        해서 총 시간은 `7T + T'` 만큼 걸린다.

2. **지연**

    - `전파지연` : 신호가 한 노드에서 다음 노드로 도달하는데 걸리는 시간
    - `전송시간` : 송신기가 한 블록의 데이터를 보내는 데 걸리는 시간
    - `노드지연` : 한 노드가 데이터를 교환할 떄 필요한 처리를 수행하는데 걸리는 시간
​

3. 회선교환과 패킷교환의 전송 시간

    1. **회선교환** 

        전송시간 <br>
        = 호 설정시간 ( 호 요청신호 + 전파지연 + 처리지연(목적지 도달) + 호 수락신호(발송지 도달) ) + 전송시간 + 확인응답신호

    2. **가상회선**
        
        전송시간 <br>
        = 호 설정시간 ( 호 요청신호 + 전파지연 + 처리지연 + 호 수락신호 + 처리지연 ) + 전송시간 + 확인응답신호(처리지연)

    3. **데이터 그램**
    
        전송시간 = 전송시간

    > 처리 지연
        회선교환의 경우 목적지 → 발송지 로 호 수락신호와 확인응답신호가 올 때는 처리지연이 발생하지 않는다.
        하지만 가상회선의 경우 패킷으로 호 설정을 하기 때문에, 목적지 → 발송지로 호 수락 신호와 확인응답 신호가 올 때에도 처리지연이 존재한다.
    {: .prompt-tip }

### 회선교환과 패킷교환의 비교

![Desktop View](/assets/img/Com-Net/1.png)